use serde::{Deserialize, Serialize};
use std::error::Error;
use std::fs::{self, File};
use std::io::{BufReader, BufWriter, Write};
use std::process::Command;

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
struct License {
    name: String,
    license_id: String,
    license_text: String,
    standard_license_header: Option<String>,
    #[serde(default)]
    see_also: Vec<String>,
    #[serde(default)]
    is_osi_approved: bool,
    #[serde(default)]
    is_fsf_libre: bool,
    is_deprecated_license_id: bool,
}

impl License {
    fn ident(&self) -> String {
        let ident = self
            .license_id
            .replace('-', "_")
            .replace('.', "_")
            .replace('+', "_plus");
        if ident == "0BSD" {
            "BSD_0".to_string()
        } else {
            ident
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
struct Exception {
    name: String,
    license_exception_id: String,
    license_exception_text: String,
    license_comments: Option<String>,
    is_deprecated_license_id: bool,
    #[serde(default)]
    see_also: Vec<String>,
}

impl Exception {
    fn ident(&self) -> String {
        let ident = self
            .license_exception_id
            .replace('-', "_")
            .replace('.', "_");
        if ident == "389_exception" {
            "exception_389".to_string()
        } else {
            ident
        }
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    let output = Command::new("git")
        .arg("pull")
        .arg("--ff-only")
        .arg("origin")
        .arg("master")
        .current_dir("../license-list-data")
        .output()?;

    if output.status.success() {
        let stdout = String::from_utf8(output.stdout)?;
        if stdout.contains("Already up to date.") {
            return Ok(());
        }

        build_licenses_from_json()?;
        build_exceptions_from_json()?;

        Command::new("cargo")
            .arg("fmt")
            .arg("--")
            .arg("../src/licenses.rs")
            .arg("../src/exceptions.rs")
            .status()?;
    }
    Ok(())
}

fn build_licenses_from_json() -> Result<(), Box<dyn Error>> {
    let mut f = BufWriter::with_capacity(4_194_304, File::create("../src/licenses.rs")?);
    let mut licenses = Vec::with_capacity(512);
    f.write_all(b"// This file is autogenerated, do not edit.\n\n")?;
    f.write_all(b"/// Returns a license based on the provided id.\n")?;
    f.write_all(b"///\n")?;
    f.write_all(b"/// # Examples\n")?;
    f.write_all(b"/// ```\n")?;
    f.write_all(b"/// let mit = license::from_id(\"MIT\").unwrap();\n")?;
    f.write_all(b"/// assert_eq!(mit.name(), \"MIT License\");\n")?;
    f.write_all(b"/// ```\n")?;
    f.write_all(b"pub fn from_id(id: &str) -> Option<&'static dyn crate::License> {\n")?;
    f.write_all(b"    match id {\n")?;
    for entry in fs::read_dir("../license-list-data/json/details")? {
        let entry = entry?;
        let rdr = File::open(entry.path())?;
        let license: License = serde_json::from_reader(BufReader::with_capacity(131_072, rdr))?;
        writeln!(
            f,
            "        {:?} => Some(&{}),",
            license.license_id,
            license.ident()
        )?;
        licenses.push(license);
    }
    f.write_all(b"        _ => None,\n")?;
    f.write_all(b"    }\n")?;
    f.write_all(b"}\n\n")?;
    for license in licenses {
        writeln!(
            f,
            include_str!("../LICENSE-TEMPLATE"),
            ident = license.ident(),
            name = license.name,
            id = license.license_id,
            text = license.license_text,
            header = license.standard_license_header,
            osi = license.is_osi_approved,
            fsf = license.is_fsf_libre,
            deprecated = license.is_deprecated_license_id,
            see_also = license.see_also,
        )?;
    }
    Ok(())
}

fn build_exceptions_from_json() -> Result<(), Box<dyn Error>> {
    let mut f = BufWriter::with_capacity(524_288, File::create("../src/exceptions.rs")?);
    let mut exceptions = Vec::with_capacity(64);
    f.write_all(b"// This file is autogenerated, do not edit.\n\n")?;
    f.write_all(b"/// Returns an exception based on the provided id.\n")?;
    f.write_all(b"///\n")?;
    f.write_all(b"/// # Examples\n")?;
    f.write_all(b"/// ```\n")?;
    f.write_all(b"/// let gcc = license::from_id_exception(\"GCC-exception-3.1\").unwrap();\n")?;
    f.write_all(b"/// assert_eq!(gcc.name(), \"GCC Runtime Library exception 3.1\");\n")?;
    f.write_all(b"/// ```\n")?;
    f.write_all(
        b"pub fn from_id_exception(id: &str) -> Option<&'static dyn crate::LicenseException> {\n",
    )?;
    f.write_all(b"    match id {\n")?;
    for entry in fs::read_dir("../license-list-data/json/exceptions")? {
        let entry = entry?;
        let rdr = File::open(entry.path())?;
        let exception: Exception = serde_json::from_reader(BufReader::with_capacity(131_072, rdr))?;
        writeln!(
            f,
            "        {:?} => Some(&{}),",
            exception.license_exception_id,
            exception.ident()
        )?;
        exceptions.push(exception);
    }
    f.write_all(b"        _ => None,\n")?;
    f.write_all(b"    }\n")?;
    f.write_all(b"}\n\n")?;
    for exception in exceptions {
        writeln!(
            f,
            include_str!("../EXCEPTION-TEMPLATE"),
            ident = exception.ident(),
            name = exception.name,
            id = exception.license_exception_id,
            text = exception.license_exception_text,
            deprecated = exception.is_deprecated_license_id,
            comments = exception.license_comments,
            see_also = exception.see_also,
        )?;
    }
    Ok(())
}
